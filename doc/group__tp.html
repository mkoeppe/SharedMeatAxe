<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Tensor Products</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__tp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tensor Products</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>These function are used for calculations with tensor products. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTkData__t.html">TkData_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor condensation state.  <a href="structTkData__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#ga19b7c8919ad63a51ebf6a877071cea0a">MatrixToVector</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *mat, <a class="el" href="structMatrix__t.html">Matrix_t</a> *vecs, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert matrix to vector.  <a href="#ga19b7c8919ad63a51ebf6a877071cea0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#gaa4e103bedf5238a4b70b0ed78afcbbfe">MatTensor</a> (const <a class="el" href="structMatrix__t.html">Matrix_t</a> *m1, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor Product.  <a href="#gaa4e103bedf5238a4b70b0ed78afcbbfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#ga86a21b33385a1a812e2ca27a492c0a11">TensorMap</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *vec, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *a, const <a class="el" href="structMatrix__t.html">Matrix_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map Under Tensor Product.  <a href="#ga86a21b33385a1a812e2ca27a492c0a11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#ga6449a538adc445e77ba6b6630fc2ff90">TK_ReadInfo</a> (<a class="el" href="structTkData__t.html">TkData_t</a> *tki, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a .tki file.  <a href="#ga6449a538adc445e77ba6b6630fc2ff90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#gac5c44affb82f75804e8f6246bd8089f8">TK_WriteInfo</a> (<a class="el" href="structTkData__t.html">TkData_t</a> *tki, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a .tki file.  <a href="#gac5c44affb82f75804e8f6246bd8089f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tp.html#gaeb0584dbb3136874f7eaf60f4e1b1958">VectorToMatrix</a> (<a class="el" href="structMatrix__t.html">Matrix_t</a> *vecs, int n, int noc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector to matrix.  <a href="#gaeb0584dbb3136874f7eaf60f4e1b1958"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga19b7c8919ad63a51ebf6a877071cea0a"></a><!-- doxytag: member="mat2vec.c::MatrixToVector" ref="ga19b7c8919ad63a51ebf6a877071cea0a" args="(const Matrix_t *mat, Matrix_t *vecs, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixToVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert matrix to vector. </p>
<p>This function converts a matrix into a row vector by concatenating the rows of the matrix. If <em>mat</em> is a r by c matrix, the resulting vector has rc entries. Instead of allocating a new buffer for the result, MatToVec() expects a pointer to a matrix, <em>vecs</em>, and puts the vector into the <em>n-th</em> row of this matrix. Of course, <em>vecs</em> must be over the smae field as <em>mat</em>, have rc columns and at least n+1 rows. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tp.html#gaeb0584dbb3136874f7eaf60f4e1b1958" title="Convert vector to matrix.">VectorToMatrix</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to convert. </td></tr>
    <tr><td class="paramname">vecs</td><td>Destination of the vector. </td></tr>
    <tr><td class="paramname">n</td><td>Row number where the vector is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4e103bedf5238a4b70b0ed78afcbbfe"></a><!-- doxytag: member="mtensor.c::MatTensor" ref="gaa4e103bedf5238a4b70b0ed78afcbbfe" args="(const Matrix_t *m1, const Matrix_t *m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* MatTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tensor Product. </p>
<p>This function calculates the (Kronecker) tensor product m1⊗m2. Both matrices must be over the same field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Pointer to the first matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Pointer to the second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tensor product of <em>m1</em> and <em>m2</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86a21b33385a1a812e2ca27a492c0a11"></a><!-- doxytag: member="temap.c::TensorMap" ref="ga86a21b33385a1a812e2ca27a492c0a11" args="(Matrix_t *vec, const Matrix_t *a, const Matrix_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* TensorMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map Under Tensor Product. </p>
<p>This function applies the tensor product of two matrices to one or more vectors. The same calculation could be done with <a class="el" href="group__mat.html#gab9718111f7c42fe1d0af862b1073d70f" title="Multiply matrices This function multiplies dest from the right by src.">MatMul()</a> and <a class="el" href="group__tp.html#gaa4e103bedf5238a4b70b0ed78afcbbfe" title="Tensor Product.">MatTensor()</a>, but this function is usually faster and uses less memory, because it does not calculate the full tensor product of a⊗b. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tp.html#gaeb0584dbb3136874f7eaf60f4e1b1958" title="Convert vector to matrix.">VectorToMatrix()</a> <a class="el" href="group__tp.html#ga19b7c8919ad63a51ebf6a877071cea0a" title="Convert matrix to vector.">MatrixToVector()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vectors to map. </td></tr>
    <tr><td class="paramname">a</td><td>Left matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Image of <em>vec</em> under <em>a⊗<em>b</em>,</em> or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6449a538adc445e77ba6b6630fc2ff90"></a><!-- doxytag: member="tkinfo.c::TK_ReadInfo" ref="ga6449a538adc445e77ba6b6630fc2ff90" args="(TkData_t *tki, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TK_ReadInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTkData__t.html">TkData_t</a> *&#160;</td>
          <td class="paramname"><em>tki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a .tki file. </p>
<p>This function reads the contents of a .tki file and puts the data into a <a class="el" href="structTkData__t.html" title="Tensor condensation state.">TkData_t</a> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tki</td><td>Pointer to a <a class="el" href="structTkData__t.html" title="Tensor condensation state.">TkData_t</a> structure where the data is stored. </td></tr>
    <tr><td class="paramname">name</td><td>File name without ".tki" extension (which is appended automatically). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5c44affb82f75804e8f6246bd8089f8"></a><!-- doxytag: member="tkinfo.c::TK_WriteInfo" ref="gac5c44affb82f75804e8f6246bd8089f8" args="(TkData_t *tki, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TK_WriteInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTkData__t.html">TkData_t</a> *&#160;</td>
          <td class="paramname"><em>tki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a .tki file. </p>
<p>This function writes the contents of a <a class="el" href="structTkData__t.html" title="Tensor condensation state.">TkData_t</a> structure into a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tki</td><td>Pointer to a <a class="el" href="structTkData__t.html" title="Tensor condensation state.">TkData_t</a> structure. </td></tr>
    <tr><td class="paramname">name</td><td>File name without ".tki" extension (which is appended automatically). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 o success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb0584dbb3136874f7eaf60f4e1b1958"></a><!-- doxytag: member="vec2mat.c::VectorToMatrix" ref="gaeb0584dbb3136874f7eaf60f4e1b1958" args="(Matrix_t *vecs, int n, int noc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrix__t.html">Matrix_t</a>* VectorToMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMatrix__t.html">Matrix_t</a> *&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert vector to matrix. </p>
<p>This function converts a vector with m=rc entries into a r by c matrix by filling the matrix from top to bottom and left to right with the entries of the vector. The vector is taken as the n-th row of <em>vecs</em>. A new matrix is allocated and returned. <em>noc</em> is the number of columns of the result, which must be a divisor of the number of columns of <em>vecs</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__tp.html#ga19b7c8919ad63a51ebf6a877071cea0a" title="Convert matrix to vector.">MatrixToVector</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>List of vectors. </td></tr>
    <tr><td class="paramname">n</td><td>Number of the vector to convert. </td></tr>
    <tr><td class="paramname">noc</td><td>Desired number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
