<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MeatAxe: Polynomials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeatAxe&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__poly.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polynomials</div>  </div>
</div>
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The MeatAxe can work with polynomials over a finite field. A polynomial is represented by a <a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> structure. Each polynomial carries the field order, i.e., you can work with polynomials over different fields on one program. However, this feature is currently of little use since all standard operations only work on polynomials over the same field, and there is no easy way to identify polynomials over a field and its subfields.</p>
<p>There is a second representation of polynomials as product of factors, see <a class="el" href="structFPoly__t.html" title="A Factored Polynomial.">FPoly_t</a>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactor__t.html">factor_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal representation of a factor.  <a href="structfactor__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFPoly__t.html">FPoly_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Factored Polynomial.  <a href="structFPoly__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPoly__t.html">Poly_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Polynomial.  <a href="structPoly__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gac8dcdb8a5bf46f754c0f59409ebe512c">Factorization</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *pol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a polynomial.  <a href="#gac8dcdb8a5bf46f754c0f59409ebe512c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga299037bcc3ed4910efe41aa60ed3ed2b">FpIsValid</a> (const <a class="el" href="structFPoly__t.html">FPoly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a Factored Polynomial.  <a href="#ga299037bcc3ed4910efe41aa60ed3ed2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga5c41ed96c8c7b5ad159fae55e7ab0383">FpAlloc</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a Factored Polynomial.  <a href="#ga5c41ed96c8c7b5ad159fae55e7ab0383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga030597eabcf0f74e3bdbe4bd316896c2">FpFree</a> (<a class="el" href="structFPoly__t.html">FPoly_t</a> *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a Factored Polynomial.  <a href="#ga030597eabcf0f74e3bdbe4bd316896c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga7d94f3ca0370e6cebc5421bfdb7e566b">FpDup</a> (const <a class="el" href="structFPoly__t.html">FPoly_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a Factored Polynomial.  <a href="#ga7d94f3ca0370e6cebc5421bfdb7e566b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga5ce0814ec1919e16a1d6c5cfb0bc7262">FpMulP</a> (<a class="el" href="structFPoly__t.html">FPoly_t</a> *dest, const <a class="el" href="structPoly__t.html">Poly_t</a> *src, int pwr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply With an Irreducible Polynomial.  <a href="#ga5ce0814ec1919e16a1d6c5cfb0bc7262"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gaf24cd4ea0814eed9c1fea946813ef433">FpMul</a> (<a class="el" href="structFPoly__t.html">FPoly_t</a> *dest, const <a class="el" href="structFPoly__t.html">FPoly_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Factored Polynomials.  <a href="#gaf24cd4ea0814eed9c1fea946813ef433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gae4da4ac58c474729145651869b3dd449">FpPrint</a> (const char *name, const <a class="el" href="structFPoly__t.html">FPoly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a factored polynomial.  <a href="#gae4da4ac58c474729145651869b3dd449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga75dcd3506bde4e8d5d013ca9344c880c">PolIsValid</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a polynomial.  <a href="#ga75dcd3506bde4e8d5d013ca9344c880c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gac3d7db46676f751fd58e13fb39589d3c">PolAlloc</a> (int fl, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a polynomial This function creates the polynomial p(x)=x^n over the current field.  <a href="#gac3d7db46676f751fd58e13fb39589d3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga90dd8c9a664c1fc00cc2332712a07a4d">PolFree</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a polynomial" This function frees a polynomial data structure and cleans up all internal data.  <a href="#ga90dd8c9a664c1fc00cc2332712a07a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga0706b04177be404c5dd691ca3029a31b">Pol_Normalize</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a polynomial.  <a href="#ga0706b04177be404c5dd691ca3029a31b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga9ad10a563475e843198315b9a624669a">PolDerive</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *pol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a Polynomial.  <a href="#ga9ad10a563475e843198315b9a624669a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga5997451b18c81943094d2b42509181a5">PolDivMod</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *a, const <a class="el" href="structPoly__t.html">Poly_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial Division.  <a href="#ga5997451b18c81943094d2b42509181a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga8775175cae836aade6bd5500e771ba25">PolMod</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *a, const <a class="el" href="structPoly__t.html">Poly_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial division.  <a href="#ga8775175cae836aade6bd5500e771ba25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gad31f030591ffb82299f59d3dcc63dd07">PolDup</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a Polynomial.  <a href="#gad31f030591ffb82299f59d3dcc63dd07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga404531733c3f3b30cb4df407ac126811">PolGcd</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *a, const <a class="el" href="structPoly__t.html">Poly_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest Common Divisor of two Polynomials.  <a href="#ga404531733c3f3b30cb4df407ac126811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga444953eb2f87c5c12d0cd3c5c21877cc">PolGcdEx</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *a, const <a class="el" href="structPoly__t.html">Poly_t</a> *b, <a class="el" href="structPoly__t.html">Poly_t</a> **result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest Common Divisor of two Polynomials.  <a href="#ga444953eb2f87c5c12d0cd3c5c21877cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gacc570eccb80b9021b35786b37149a68d">PolMul</a> (<a class="el" href="structPoly__t.html">Poly_t</a> *dest, const <a class="el" href="structPoly__t.html">Poly_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Polynomials.  <a href="#gacc570eccb80b9021b35786b37149a68d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga64decb06635fd6e159927100c85582df">PolPrint</a> (char *name, const <a class="el" href="structPoly__t.html">Poly_t</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a Polynomial This function prints a polynomial on the standard output in a human-readable form.  <a href="#ga64decb06635fd6e159927100c85582df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gaa425a0a1990d95e836edb42634c40226">PolRead</a> (FILE *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a Polynomial from a File.  <a href="#gaa425a0a1990d95e836edb42634c40226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga6257721a9bf819bef712cf6665bd8644">PolLoad</a> (const char *fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a Polynomial from a File.  <a href="#ga6257721a9bf819bef712cf6665bd8644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga829c24231ff2317710547fd6279566f5">PolWrite</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *p, FILE *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a polynomial to a file.  <a href="#ga829c24231ff2317710547fd6279566f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gab8a15fe8843a478010aba8dc373e8809">PolSave</a> (const <a class="el" href="structPoly__t.html">Poly_t</a> *pol, const char *fn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a Polynomial to a File.  <a href="#gab8a15fe8843a478010aba8dc373e8809"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac8dcdb8a5bf46f754c0f59409ebe512c"></a><!-- doxytag: member="berlekmp.c::Factorization" ref="gac8dcdb8a5bf46f754c0f59409ebe512c" args="(const Poly_t *pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFPoly__t.html">FPoly_t</a>* Factorization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factor a polynomial. </p>
<p>This function decomposes a polynomial into irreducible factors using the Berlekamp algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Polynomial to factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The factorization of <em>pol</em> or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c41ed96c8c7b5ad159fae55e7ab0383"></a><!-- doxytag: member="fpcore.c::FpAlloc" ref="ga5c41ed96c8c7b5ad159fae55e7ab0383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFPoly__t.html">FPoly_t</a>* FpAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a Factored Polynomial. </p>
<p>This function creates a new Fpoly_t structure. The new polynomial is empty, i.e., it has no factors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the new <a class="el" href="structFPoly__t.html" title="A Factored Polynomial.">FPoly_t</a> structure or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d94f3ca0370e6cebc5421bfdb7e566b"></a><!-- doxytag: member="fpdup.c::FpDup" ref="ga7d94f3ca0370e6cebc5421bfdb7e566b" args="(const FPoly_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFPoly__t.html">FPoly_t</a>* FpDup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a Factored Polynomial. </p>
<p>This function creates a copy of a factored polynomial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to a factored polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a copy of <em>src</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga030597eabcf0f74e3bdbe4bd316896c2"></a><!-- doxytag: member="fpcore.c::FpFree" ref="ga030597eabcf0f74e3bdbe4bd316896c2" args="(FPoly_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FpFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a Factored Polynomial. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structFPoly__t.html" title="A Factored Polynomial.">FPoly_t</a> <a class="el" href="group__poly.html#ga5c41ed96c8c7b5ad159fae55e7ab0383" title="Allocate a Factored Polynomial.">FpAlloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga299037bcc3ed4910efe41aa60ed3ed2b"></a><!-- doxytag: member="fpcore.c::FpIsValid" ref="ga299037bcc3ed4910efe41aa60ed3ed2b" args="(const FPoly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FpIsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a Factored Polynomial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <em>p</em> is a valid factores polynomial, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf24cd4ea0814eed9c1fea946813ef433"></a><!-- doxytag: member="fpmul2.c::FpMul" ref="gaf24cd4ea0814eed9c1fea946813ef433" args="(FPoly_t *dest, const FPoly_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFPoly__t.html">FPoly_t</a>* FpMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply Factored Polynomials. </p>
<p>Multiplies <em>dest</em> by <em>src</em>. The previous content of <em>dest</em> is lost. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga5ce0814ec1919e16a1d6c5cfb0bc7262" title="Multiply With an Irreducible Polynomial.">FpMulP()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Factored polynomial to modify. </td></tr>
    <tr><td class="paramname">src</td><td>Factored polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns |dest| or |NULL| on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ce0814ec1919e16a1d6c5cfb0bc7262"></a><!-- doxytag: member="fpmul.c::FpMulP" ref="ga5ce0814ec1919e16a1d6c5cfb0bc7262" args="(FPoly_t *dest, const Poly_t *src, int pwr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFPoly__t.html">FPoly_t</a>* FpMulP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pwr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply With an Irreducible Polynomial. </p>
<p>This function multiplies a factored polynomial with the power of an an irreducible factor. It is not checked that <em>src</em> is irreducible. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#gaf24cd4ea0814eed9c1fea946813ef433" title="Multiply Factored Polynomials.">FpMul()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Factored polynomial to modify. </td></tr>
    <tr><td class="paramname">src</td><td>Irreducible polynomial. </td></tr>
    <tr><td class="paramname">pwr</td><td>Power of the irreducible polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>dest</em> or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4da4ac58c474729145651869b3dd449"></a><!-- doxytag: member="fpprint.c::FpPrint" ref="gae4da4ac58c474729145651869b3dd449" args="(const char *name, const FPoly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FpPrint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFPoly__t.html">FPoly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a factored polynomial. </p>
<p>This function prints a factored polynomial to the standard output. If <em>name</em> is not 0, "name=" is printed before the polynomial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the polynomial or 0. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to the factored polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0706b04177be404c5dd691ca3029a31b"></a><!-- doxytag: member="polcore.c::Pol_Normalize" ref="ga0706b04177be404c5dd691ca3029a31b" args="(Poly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Pol_Normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a polynomial. </p>
<p>This function makes sure that the leading coefficient of a polynomial is non-zero. </p>

</div>
</div>
<a class="anchor" id="gac3d7db46676f751fd58e13fb39589d3c"></a><!-- doxytag: member="polcore.c::PolAlloc" ref="gac3d7db46676f751fd58e13fb39589d3c" args="(int fl, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolAlloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a polynomial This function creates the polynomial p(x)=x^n over the current field. </p>
<p>If n is negative, a zero polynomial is created. The return value is a pointer to a newly allocated <a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> structure. The caller is responsible for releasing memory by calling <a class="el" href="group__poly.html#ga90dd8c9a664c1fc00cc2332712a07a4d" title="Free a polynomial" This function frees a polynomial data structure and cleans up all internal data...">PolFree()</a> when the polynomial is no longer needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>Field order. </td></tr>
    <tr><td class="paramname">n</td><td>Degree of the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a new <a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> structure or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ad10a563475e843198315b9a624669a"></a><!-- doxytag: member="polderive.c::PolDerive" ref="ga9ad10a563475e843198315b9a624669a" args="(Poly_t *pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolDerive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Derive a Polynomial. </p>
<p>This function derives a polynomial. Note that the derived polynomial is stored in <em>pol</em>, replacing the original polynomial. The following piece of code shows how to keep the original polynomial intact while calculating the derivative: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> *pol, *der;
 ...
 der = <a class="code" href="group__poly.html#ga9ad10a563475e843198315b9a624669a" title="Derive a Polynomial.">PolDerive</a>(<a class="code" href="group__poly.html#gad31f030591ffb82299f59d3dcc63dd07" title="Duplicate a Polynomial.">PolDup</a>(pol));
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>pol</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5997451b18c81943094d2b42509181a5"></a><!-- doxytag: member="poldiv.c::PolDivMod" ref="ga5997451b18c81943094d2b42509181a5" args="(Poly_t *a, const Poly_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolDivMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polynomial Division. </p>
<p>This function performs a polynomial division. Given two polynomials a and bâ‰ 0 over the same field, PolDivMod() finds two polynomials q and r such that a=qb+r, and deg(r)&lt;deg(b).</p>
<p>The quotient q is returned as the function result. This is a newly allocated polynomial. The caller is responsible for deleting the quotient when it no longer needed.</p>
<p>The remainder r, is stored in <em>a</em> and replaces the original value. If you need to preserve the value of <em>a</em> you must make a copy using <a class="el" href="group__poly.html#gad31f030591ffb82299f59d3dcc63dd07" title="Duplicate a Polynomial.">PolDup()</a> before calling PolDivMod(). <em>b</em> is not changed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga8775175cae836aade6bd5500e771ba25" title="Polynomial division.">PolMod()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First polynomial (numerator) on call, remainder on return. </td></tr>
    <tr><td class="paramname">b</td><td>Second polynomial (denominator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quotient or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gad31f030591ffb82299f59d3dcc63dd07"></a><!-- doxytag: member="poldup.c::PolDup" ref="gad31f030591ffb82299f59d3dcc63dd07" args="(const Poly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolDup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a Polynomial. </p>
<p>This function creates a copy of an existing polynomial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of <em>p</em> or 0 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#gac3d7db46676f751fd58e13fb39589d3c" title="Allocate a polynomial This function creates the polynomial p(x)=x^n over the current field...">PolAlloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga90dd8c9a664c1fc00cc2332712a07a4d"></a><!-- doxytag: member="polcore.c::PolFree" ref="ga90dd8c9a664c1fc00cc2332712a07a4d" args="(Poly_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PolFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a polynomial" This function frees a polynomial data structure and cleans up all internal data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>$0$ on success, $-1$ on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga404531733c3f3b30cb4df407ac126811"></a><!-- doxytag: member="polgcd.c::PolGcd" ref="ga404531733c3f3b30cb4df407ac126811" args="(const Poly_t *a, const Poly_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolGcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greatest Common Divisor of two Polynomials. </p>
<p>This function calculates the gratest common divisor of two poynomials. The polynomials must be over the same field, and at least one of them must be different from zero. Unlike most polynomial functions, <a class="el" href="group__poly.html#ga404531733c3f3b30cb4df407ac126811" title="Greatest Common Divisor of two Polynomials.">PolGcd()</a> normalizes the result, i.e., the leading coefficient of the g.c.d., is always one. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga444953eb2f87c5c12d0cd3c5c21877cc" title="Greatest Common Divisor of two Polynomials.">PolGcdEx()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First polynomial. </td></tr>
    <tr><td class="paramname">b</td><td>Second polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Greatest common divisor of <em>a</em> and <em>b</em>, 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga444953eb2f87c5c12d0cd3c5c21877cc"></a><!-- doxytag: member="polgcd.c::PolGcdEx" ref="ga444953eb2f87c5c12d0cd3c5c21877cc" args="(const Poly_t *a, const Poly_t *b, Poly_t **result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PolGcdEx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greatest Common Divisor of two Polynomials. </p>
<p>Given two polynomials a and b, this function calculates the greatest common divisor g=gcd(a,b) and two polynomials p, q such that g=pa+qb. Both <em>a</em> and <em>b</em> must be nonzero. The leading coefficient of g is always one.</p>
<p><em>result</em> must be a pointer to an array of three <code><a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> *</code> elements. If the function is successful, pointers to g, p, and q have been stored in result[0], result[1], and result[2], respectively. The caller is responsible for destroying these polynomials when they are no longer needed. In particular, you must not use the same |result| buffer again with PolGcdEx() before the contents have been freed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga404531733c3f3b30cb4df407ac126811" title="Greatest Common Divisor of two Polynomials.">PolGcd()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First polynomial. </td></tr>
    <tr><td class="paramname">b</td><td>Second polynomial. </td></tr>
    <tr><td class="paramname">result</td><td>Result buffer for the g.c.d. and coefficients (see below). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on sucess, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75dcd3506bde4e8d5d013ca9344c880c"></a><!-- doxytag: member="polcore.c::PolIsValid" ref="ga75dcd3506bde4e8d5d013ca9344c880c" args="(const Poly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PolIsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a polynomial. </p>
<p>This function checks if the argument is a pointer to a valid polynomial. If the polynomial the function returns 1. Otherwise, an error is signalled and, if the error handler does not terminate the program, the function returns 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <em>p</em> points to a valid polynomial, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6257721a9bf819bef712cf6665bd8644"></a><!-- doxytag: member="polread.c::PolLoad" ref="ga6257721a9bf819bef712cf6665bd8644" args="(const char *fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolLoad </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a Polynomial from a File. </p>
<p>This function opens a file, reads a single polynomial, and closes the file. The return value is a pointer to the polynomial or NULL on error. If the file contains more than one polynomial, only the first one is read.</p>
<p>If a polynomial was successfully read, the function returns a pointer to a newly created <a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> object. The caller is responsible for deleting this object as soon as it no longer needed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#gaa425a0a1990d95e836edb42634c40226" title="Read a Polynomial from a File.">PolRead()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the polynomial read from the file, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8775175cae836aade6bd5500e771ba25"></a><!-- doxytag: member="poldiv.c::PolMod" ref="ga8775175cae836aade6bd5500e771ba25" args="(Poly_t *a, const Poly_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polynomial division. </p>
<p>This function replaces <em>a</em> with the remainder of the division of <em>a</em> by <em>b</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga5997451b18c81943094d2b42509181a5" title="Polynomial Division.">PolDivMod()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First polynomial (numerator) on call, remainder on return. </td></tr>
    <tr><td class="paramname">b</td><td>Second polynomial (denominator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>a</em> or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc570eccb80b9021b35786b37149a68d"></a><!-- doxytag: member="polmul.c::PolMul" ref="gacc570eccb80b9021b35786b37149a68d" args="(Poly_t *dest, const Poly_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply Polynomials. </p>
<p>This function multiplies <em>dest</em> by <em>src</em> and returns <em>dest</em>. The polynomials must be over the same field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the first polynomial. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the second polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>dest</em>, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64decb06635fd6e159927100c85582df"></a><!-- doxytag: member="polprint.c::PolPrint" ref="ga64decb06635fd6e159927100c85582df" args="(char *name, const Poly_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PolPrint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a Polynomial This function prints a polynomial on the standard output in a human-readable form. </p>
<p>If <em>name</em> is not 0, the name followed by an equal sign is printed before the polynomial. For example, the statement <code>PolPrint("P",P)</code> could produce the following output: </p>
<pre>
 P=3x^2+x+1</pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to print before the polynomial or 0. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to the polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa425a0a1990d95e836edb42634c40226"></a><!-- doxytag: member="polread.c::PolRead" ref="gaa425a0a1990d95e836edb42634c40226" args="(FILE *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPoly__t.html">Poly_t</a>* PolRead </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a Polynomial from a File. </p>
<p>This function reads a polynomial from a file. If successful, the return value is a pointer to a new <a class="el" href="structPoly__t.html" title="A Polynomial.">Poly_t</a> object. The caller is responsible for deleting this polynomial with <a class="el" href="group__poly.html#ga90dd8c9a664c1fc00cc2332712a07a4d" title="Free a polynomial" This function frees a polynomial data structure and cleans up all internal data...">PolFree()</a> when it is no longer needed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga6257721a9bf819bef712cf6665bd8644" title="Read a Polynomial from a File.">PolLoad()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the polynomial, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8a15fe8843a478010aba8dc373e8809"></a><!-- doxytag: member="polwrite.c::PolSave" ref="gab8a15fe8843a478010aba8dc373e8809" args="(const Poly_t *pol, const char *fn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PolSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a Polynomial to a File. </p>
<p>This function creates a file, writes a single polynomial to the file and closes the file. If a f ile with the specified name already exists, it's contents are destroyed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#ga829c24231ff2317710547fd6279566f5" title="Write a polynomial to a file.">PolWrite</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Polynomial to write. </td></tr>
    <tr><td class="paramname">fn</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga829c24231ff2317710547fd6279566f5"></a><!-- doxytag: member="polwrite.c::PolWrite" ref="ga829c24231ff2317710547fd6279566f5" args="(const Poly_t *p, FILE *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PolWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoly__t.html">Poly_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a polynomial to a file. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__poly.html#gab8a15fe8843a478010aba8dc373e8809" title="Write a Polynomial to a File.">PolSave()</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the polynomial. </td></tr>
    <tr><td class="paramname">f</td><td>File to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"><address style="text-align: right;"><small>
MeatAxe 2.4 documentation, generated on Mon Nov 28 2011 22:17:18</small></address>
</body>
</html>
